if (isdigit(peek(contents, token_index)))
{
    curr_token.type = token_type_e::type_int_lit;
    std::string num;
    switch (peek(contents, token_index)
    {
        case '*':
            token.type = toketype_e::type_mul;
            consume(contents, token_index);
            break;
        case '/':
            token.type = toketype_e::type_div;
            consume(contents, token_index);
            break;
        case '+':
            token.type = toketype_e::type_add;
            consume(contents, token_index);
            break;
        case '-':
            token.type = toketype_e::type_sub;
            consume(contents, token_index);
            break;
        default:
            break;
    }
    while (isdigit(peek(contents, token_index))) {
        num += peek(contents, token_index);
        consume(contents, token_index);
    }
    curr_token.value = num;
}


else if (word == "*")
            {
                curr_token.type = token_type_e::type_mul;
                consume(contents, token_index);
            }
            else if (word == "/")
            {
                curr_token.type = token_type_e::type_div;
                consume(contents, token_index);
            }
            else if (word == "+")
            {
                std::cout << "+ found" << std::endl;
                curr_token.type = token_type_e::type_add;
                consume(contents, token_index);
            }
            else if (word == "-")
            {
                curr_token.type = token_type_e::type_sub;
                consume(contents, token_index);
            }




token = peek_token(token_stream, token_index);
            if (token && token->type == token_type_e::type_int_lit)
            {
                root_node.child_node_1 = std::make_unique<ast_node_t>();
                root_node.child_node_1->type = token->type;
                root_node.child_node_1->int_value = stoi(token->value);
                consume_token(token_stream, token_index);


                const token_t* next_token = peek_token(token_stream, token_index);
                if (next_token && (next_token->type == token_type_e::type_add ||
                                   next_token->type == token_type_e::type_sub ||
                                   next_token->type == token_type_e::type_mul ||
                                   next_token->type == token_type_e::type_div))

                {
                    // Root node is mathematical operator
                    root_node.type = token->type;
                    consume_token(token_stream, token_index);

                    // First (left) node is first value of operation
                    root_node.child_node_1 = std::make_unique<ast_node_t>();
                    root_node.child_node_1->type = token_type_e::type_int_lit;
                    root_node.child_node_1->int_value = root_node.child_node_1->int_value;
                    root_node.child_node_1 = std::move(root_node.child_node_1);
                    consume_token(token_stream, token_index);


                    // Second (right) node is second value of operation
                    root_node.child_node_2 = std::make_unique<ast_node_t>();
                    root_node.child_node_2->type = token_type_e::type_int_lit;
                    root_node.child_node_2->int_value = stoi(token->value);
                    consume_token(token_stream, token_index);
                }
            }

            program_ast.push_back(std::move(root_node));
        }